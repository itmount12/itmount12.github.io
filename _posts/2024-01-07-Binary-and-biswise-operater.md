# [파이썬] 이진법과 비트 연산자(binary number and bitwise operator)

프로그래밍 언어에서 2진수는 특별합니다.

컴퓨터와 같은 전자 기기의 경우 
신호를 꺼졌는지(0), 켜졌는지(1)를 기반으로 구별할수 밖에 없기 때문입니다.

## 0.10진법

사람이 사용하는 숫자의 경우 1,2,3,4,5,6,7,8,9 그리고 0을 사용하는데,

이 아라비아 숫자들은 10개 밖에 존재하지 않아 9를 넘어가는 순간

표현 방법을 다시 가장 작은 수로 돌아가고 0을 붙혀 10이란 수를 만들게 
됩니다.

이것이 10진법의 알고리즘입니다. 10, 100, 1000 과 같이 10의 거듭 제곱에서

수가 한 자리 '나아가게 되는' (나아갈 진) 수를 세는 방법입니다.

## 1.2진법
그렇다면 2진법의 경우는 어떨까요? 10진법에서는 0~9의 숫자를 사용합니다.

2진법은 10진법과 마찬가지로 2의 거듭 제곱에서 수가 나아가게 되겠죠? 

따라서 이진법은 0, 1 이 두개의 숫자만을 사용하게 됩니다. 

다음은 이진법으로 1,2,3,4,5 를 표현하겠습니다.

**먼저 1입니다.**

이진법에서는 사용할수 있는 수가 0, 1이므로 이진법 1은 1을 그대로

사용하면 됩니다

**다음으로는 2 입니다.**

이진법에서는 사용할 수 있는 수가 0,1 이므로 2를 표현하려면 자리수를 한

칸 옮긴 후 0을 붙혀서 한 자리 나아감을 표현 하면 됩니다.

따라서 이진법 2는 10입니다.

**다음으로는 3입니다**

이진법에서는 3이 존재 하지 않으므로, 2+1 로 나누어 생각해 봅시다.

아까 말한 바와 같이 2는 이진법에서 10으로 표현됩니다.

그러면 이진법 세상의 3을 써보면 10 + 1 즉 11 이 3이 됩니다.

**다음으로는 4를 보겠습니다.**

4의 경우 2의 2승입니다. 

**2진법에서 2의 거듭제곱 형태는 각각 10,100,1000 과 같은 형태입니다.**

2의 2승이니 뒤에 0이 두번 붙게 되고, 4는 100으로 표현 됩니다.

**같은 방법으로 5는 2의 2승 +1 즉 101로 표현 되어집니다.**

이렇게 10진법의 수를 2진법으로 표현하는 방법을 알아봤습니다.
하지만 수가 커지면 직접 연산하는 것은 경제적이지 못하겠죠?
그래서 파이썬에서는 bin() 함수를 사용합니다.

# bin(2진수로 변환할 10진수)


```python
bin(2) #0b 뒤의 수가 2진수로 변환된 형태 입니다.
```




    '0b10'




```python
bin(11) #8+3 1000 + 11 : 의삼할 필요 없이 잘 변환 된 것을 볼수 있습니다.
```




    '0b1011'



이렇게 bin 함수를 이용하면 2진수 표현이 가능해집니다. 

## 이진수의 음수 표현

그렇다면 이진수도 음수 표현이 가능할까요?

이진수도 음수 표현이 가능합니다. 

이진수의 음수 표현에 필요한 지식은 msb 와 보수입니다.

### MSB(Most Significiant Bit)

예를 들어 17을 이진 표현 해보겠습니다.


```python
bin(17)
```




    '0b10001'



10001 이란 값이 나옵니다. 여기서 17을 구성하는데

기여도가 높은 1은 어느쪽일까요?

정답은 가장 앞에 위치한 1입니다. 

앞의 비트(표현 가능한 자리?) 가 1, 0차이에 따라

수가 16씩이나 차이가 나기 때문입니다.

이렇게 수 전체에 기여도가 가장 큰 비트를 MSB로 명명합니다.

숫자가 양수냐, 음수냐도 같은 맥락으로 생각해 봅시다.

만원을 번 것이랑(+10000) 만원을 잃은 것이랑 (-10000)

엄청난 차이겠죠?

이 아이디어를 바탕으로 생각해 보면 

이진법에서의 양수 음수는 **MSB가 1이나 0이냐**로 정해집니다.

결론적으로 msb 가 0이면 양수, msb 가 1이면 음수를 표현합니다. 

## 보수

보수란 두 수를 더했을때에 그 자릿수를 0으로 만들어 주는 수 입니다.

10진법의 3을 예로 들어봅시다 3에 어떤 수를 더해야 자리수가 0이 될까요?

정답은 7입니다. 3+7을 하게 되면 10이 되어서 그 자리수가 0이 되기 때문입니다.

다음으로는 0이 된다는 의미에 대해서 생각해 봅시다.

2에 어떤 수를 더하면 0이 될까요? 8도 있지만 여기서는 음수를 생각해 봅시다

2에 - 2를 더하면 0이 됩니다.

이제 결론입니다. 이진수에서 음수를 표현 하는 방법은 

양수로 표현한 이진수와 음수로 표현한 이진수를 더해서 0이 되게 만들어 주면 됩니다.

구체적인 예를 들어보겠습니다. 

10의 이진 표현은 1010입니다.


```python
bin(10)
```




    '0b1010'



이 수는 양수이므로 5비트 표현을 하면 01010 으로 표현 되어집니다.

양수이므로 앞에 최상위비트는 0이 됩니다.

* bit: 정보량의 최소 단위로 1과 0값만 가진다.

0 1010 이 10의 5비트 표현이 됩니다. 즉 5자리 수로 10을 표현 한 겁니다.

이 수에 어떤 수를 더해서 0이 되려면 어떻게 해야 할까요?

이진법의 세상에서는 다음와 같은 과정을 거칩니다.

먼저 0 1010 에서 0은 1로 , 1은 0으로 전부 바꿔 줍니다.

1 0101이 나오게 되고 여기에 1을 더해줍니다.

1 0110 이라는 값이 나왔습니다

0 1010

이렇게 만들어진 두 수를 더해 보면 자리가 더해지면서 0
으로 채워지고 모든 값이 0이 되는 것을 알 수 있습니다.


## 16진법

컴퓨터가 2진법을 사용하는 이유는 알겠는데, 
16진법은 왜 쓰는 것일까요?

바로 메모리 용량의 문제입니다.

16진법에서 수를 표현 하는 방법을 보겠습니다.
- 1 :1
- 2: 2
- 3 :3
- 4에서9: 4에서 9
- 10: A
- 11: B
- 12: C
- 13: D
- 14: E
- 15: F

16 진수는 10~ 15의 수에 a부터 f의 문자로 대체합니다.

즉 이진수 15 -> 1111 을 f라는 문자 하나로 대체하기에

메모리 용량에서 엄청난 이득을 보기 때문입니다.

10111010101010101011110100010라는 2진법을 16진법으로 바꿔 보겠습니다.

1 0111 0101 0101 0101 0111 1010 0010 와 같이 4 자리로 끊은 후에 각 자리수를 16진법으로 변환하면 됩니다.

1 0111(7) 0101(5) 0101(5) 0111(7) 1010(10->A) 0010(2) ->  17557A2

위와 같이, 획기적인 메모리 축소를 보입니다.

# 2.비트 연산자

비트 연산자는 비트 단위에서 연산을 수행하는 연산자입니다.

그렇다면 비트 연산을 하는 이유는 무엇일까요? 

16진수의 사용과 같이 효율적인 메모리 사용을 위함입니다.

또한 연산 속도가 빠른 것도 비트 연산의 장점입니다.

### 2-1.비트 연산자의 종류와 기능

- &: ampresand: 비트 and 연산자
   - : 대응 되는 비트 모두 1이면 1을 반환함

11011 &

10101 

10001

위수를 다시 10진법으로 변환해 보면,


```python
a= int('0b11011',2) #이진수를 다시 정수처리 하는 함수, 정수화 하는데 자주 쓰임.
```


```python
b = int('0b10101',2)
```


```python
c =int('0b10001',2)
```


```python
dec = [a,b,c]
```


```python
print(dec)
```

    [27, 21, 17]
    


```python
27 & 21
```




    17



**and 연산자의 용도: mask 계산**

추출하고 싶은 자리에 and 연산을 수행하면 원하는 부분만 추출이 가능하다.

11011 에서 중앙의 101 부분만 추출하고 싶을 때,

01110 으로 원하는 자리에 1을 넣고 and 연산을 하면

01010 원하는 부분만 추출이 가능하다.

- | :Pipe: 비트 or 연산자
    - : 대응 되는 비트 중에서 하나라도 1이면 1을 반환한다.

11011 =a

10101 =b

11111 = d


```python
d = int('0b11111',2)
```


```python
a|b
```




    31




```python
d
```




    31



치환의 기능을 가지고 있습니다. 예를 들어 원하는 위치에 1을 넣어 or 연산을 하면 해당 위치는 1이 됩니다. (1이 하나라도 있으면 1 반환)

- ^: Caret: 비트 XOR 연산자
    - : 대응 되는 두 비트가 다르면 1, 같으면 0을 반환한다.

11011 =a

10101 =b

01110 =e


```python
e= int('0b01110',2)
```


```python
e
```




    14




```python
a^b == e
```




    True



^ 연산자의 용도: 비교로 결과값이 같으면 모든 비트다 0이다.

- ~: Tilde: 비트 Not 연산자: 모든 비트 값을 반전시킨다
    - 1의 보수를 구하는 비트
- << : 지정한 수 만큼 전부 왼쪽으로 이동시킴: 2를 곱하는 효과


```python
2 << 1
```




    4




```python
2 << 2
```




    8



2의 이진 표현은 10이다 <<n 은 n칸 비트를 옮기는 역할을 합니다.
이때 값이 이동한 후의 비트의 자리는 0으로 채워집니다.

2진수에서 비트를 1칸 옮기는 뜻은 n칸 만큼 2^n 를 곱하는 것과 같습니다.

따라서 << 연산자는 2^n 승만큼 곱하는 의미로도 사용되어집니다.

- ">>" : 지정한 수 만큼 전부 오른쪽으로 이동시킴: 오른쪽 쉬프트 연산자


```python
2>>1
```




    1




```python
5>>2
```




    1



101 을 두번 오른쪽으로 밀었을 때,

001 이 되어서 1이 나오게 됩니다.

즉 LSB를넘어서 밀려나게 되면 그 비트의 값 자체가 없어지는 것을 확인 할 수 있습니다
*lsb(least significant bit) 가장 낮은 위치의 비트


```python

```

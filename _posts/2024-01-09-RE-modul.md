# [파이썬] 정규 표현식 모듈:re

파이썬에서는 메타 문자를 이용하여 정규 표현식을 만들고, 이러한 패턴들을 특정 문자열에 적용하여 문자를 처리 할 수 있는 re 모듈을 제공합니다. 


```python
import re
#re 모델을 컴파일 합니다.
```

#### 잠깐. 모듈, 패키지, 임포트 란 무엇인가?

모듈: 함수, 변수, 클래스 등을 포함하는 파일입니다. 다른 파이썬 프로그램에서 재 사용할수 있는 코드를 포함하고 있습니다. 예를 들면 math 모듈은 수학 함수를 제공하고, random 모듈은 난수를 생성하는 함수를 제공합니다.

패키지: 패키지는 모듈을 하나의 디렉토리에 모아 놓은 것입니다. 패키지는 각각의 모듈을 더 구조적으로 관리하고 구성할 수 있도록 도와줍니다. 패키지는 서브 패키지를 포함 할수 있으며, 계층적인 구조로 모듈을 구성할수 있습니다. 예를 들어 numpy 는 과학 계산을 위한 모듈과 패키지를 포함하는 대표적인 예시 입니다.

임포트 : 임포트는 다른 모듈이나 패키지의 기능을 현재 파이썬 스크립트나 프로 그램에서 사용 할수 있게 가져오는 것을 말합니다. import 키워드를 사용하여 모듈이나 패키지를 현재 네임 스페이스로 가져올 수 있습니다. 이를 통해 외부에서 제공하는 다양한 기능을 사용할 수 있습니다.

다시 정규 표현식 모듈로 돌아 오겠습니다. 
설명에 의거하여, import re 는 정규 표현식과 관련된 함수들이 포함된 파일을 현재 파이썬 스크립트에서 사용할 수 있도록 하는 코드입니다. 

## 1.re 모듈의 함수

1-1. match ( 특정 패턴, 문자열. 플래그: 보통 플래그는 일반적으로 생략됩니다)

'harry' 를 패턴으로 보겠습니다.


```python
print(re.match('harry','hagrid'))
```

    None
    


```python
print(re.match('harry','carry'))
```

    None
    


```python
print(re.match('harry', 'harry potter'))
```

    <re.Match object; span=(0, 5), match='harry'>
    


```python
print(re.match('harry', 'james harry'))
```

    None
    

re.match 함수가 반환하는 객체는 re.match 객체입니다. 이 객체는 매치된 부분(해리) 의 위치 정보를 포함합니다. span 은 매치된 시작과 끝을 튜플로 반환합니다.

re.match 함수는 주어진 패턴이 **문자열의 시작에서 매치** 되는지를 확인합니다. 따라서, james harry 는 매치 되지 않는 것을 확인 할 수 있습니다.

1.2. search(패턴, 문자열, 플래그)


```python
print(re.search('harry', 'james harry'))
```

    <re.Match object; span=(6, 11), match='harry'>
    

search 함수는 match 와는 다르게, 전체적으로 문장을 스캔해 일치하는 패턴이 있으면 이를 re.match 객체로 리턴합니다.  마찬가지로, 매치되는 인덱스를 튜플로 표시해 반환합니다.

위의 두 함수들은 패턴이 주어지면 re.match 객체로 리턴하고, 어느 부분이 매치 되는지를 인덱스 사이의 두 지점을 튜플화 시켜서 나타냅니다. 

그렇다면 패턴과 일치하는 모든 문자열의 리스트를 얻고 싶을때는 어떻게 할까요?

그 때에 사용 되는 함수가 바로  findall 함수 입니다.

1.3 findall(패턴, 문자열)

정규 표현을 다음과 같이 가정해 봅시다 : [^0-9] 또는 \D

즉, 숫자를 제외한다는 의미입니다. 

스트링은 다음과 같이 주어집니다.


```python
string ="2곱하기 4는 8"
```


```python
print(re.findall('[^0-9]', string))
```

    ['곱', '하', '기', ' ', '는', ' ']
    

결과물로 숫자가 제외된 나머지 부분이 리스트로 반환되었습니다.


```python
print(re.findall('\d', string))
```

    ['2', '4', '8']
    

1.4 finditer (패턴, 문자열)

finditer 는 findall 과 유사하지만, 반환되는 객체는 리스트가 아닌 반복자입니다.

구태여 리스트도 반복자 문법을 사용할수 있는데 왜 이렇게 반환하냐고 한다면, 

1.메모리에 저장을 할 필요가 없고, 

2.지연 평가(결과가 필요한 시점에만 계산됨) 가 가능하기에 

**대용량 데이터셋에서는 finditer가 더 효율적이라고 볼 수 있습니다.**


```python
a=re.finditer('\d', string)
b=re.findall("\D",string)
```


```python
a
```




    <callable_iterator at 0x11f091023b0>




```python
for i in a:
    print(i)
```

    <re.Match object; span=(0, 1), match='2'>
    <re.Match object; span=(5, 6), match='4'>
    <re.Match object; span=(8, 9), match='8'>
    


```python
for i in b:
    print(i)
```

    곱
    하
    기
     
    는
     
    

1.5. 더 엄격한 탐색법, fullmatch

fullmatch는 문자열의 시작과 끝이 정확하게 패턴이 일치 될때만 값을 반환합니다.

예를 들어보겠습니다.


```python
string2= "onlyone"
```


```python
print(re.fullmatch(string2,"everyone"))
print(re.fullmatch(string2,"onlyyou"))
print(re.fullmatch(string2,"onlyoneonlyone"))
print(re.fullmatch(string2,"onlyone"))
```

    None
    None
    None
    <re.Match object; span=(0, 7), match='onlyone'>
    

두 개가 중복되는 것도 허락하지 않는 엄격한 조건입니다. #^onlyone$

1.6.split

split 함수는 문자열에서 패턴이 맞으면 이를 기점으로 리스트를 쪼개는 함수 입니다. 만약 3번째 인자인 플래그를 지정하면, 문자열을 지정한 수 만큼 쪼개고 그 수가 도달하면 쪼개지 않습니다.


```python
pattern="대상"
```


```python
re.split(pattern,"대상혁대상포진대상자대상혁은신이야")
```




    ['', '혁', '포진', '자', '혁은신이야']




```python
re.split(pattern,"대상혁대상포진대상자대상혁은신이야",3)
```




    ['', '혁', '포진', '자대상혁은신이야']



플래그 갑에 3을 주어서, "대상" 이나타난 전후로 나누어서 "" 을 생성

첫번째 대상을 기준으로 "혁"

두번째 대상을 기준으로 "포진"

세번째 대상을 기준으로 "자"

그 이후로는 나누지 않아서 뒤의  대상혁은 신이야는 그대로 남아있게 됩니다

1.6.sub, subn(패턴, 교체할 문자열, 문자열, 최대 교체 수, 플래그)

sub는 문자열에 맞는 패턴을 교체할 문자열로 교체 합니다. 최대 교체 수에 도달하면 더 이상 교체 하지 않습니다.


```python
string2 = "맛없는 소고기. 맛없는 김치. 맛없는 칼국수"
```


```python
re.sub("맛없는" , "맛있는", string2)
```




    '맛있는 소고기. 맛있는 김치. 맛있는 칼국수'




```python
re.subn('맛없','맛있',string2,1)
```




    ('맛있는 소고기. 맛없는 김치. 맛없는 칼국수', 1)



subn 은 반환결과를 문자열, 매칭 횟수의 튜플로 반환합니다.

compile(패턴,플래그) : 패턴과 플래그가 동일한 정규식을 여러 번 사용하려면, compile 을 사용해 지정하고 다른 함수를 사용하면 됩니다.


```python
pattern = re.compile(r'\d+')
```

r =raw string: 이스케이프 문자를 해석하지 않고 문자열로 처리한다는 뜻입니다.

즉 \를 특수한 의미로 해석하는게 아닌 문자 그대로 처리하겠다는 뜻!

=r"\d" 이후에 나오는 \는 문자 처리 하겠다는 뜻!


```python
pattern
```




    re.compile(r'\d+', re.UNICODE)




```python
#숫자가 1번 이상 나오는 것을 매치 하는 새 규칙이 pattern 에 저장되었습니다.
```


```python
print(pattern.sub("일이삼","123사오"))
```

    일이삼사오
    

pattern 에 의해 숫자가 1번 이상 나오는 패턴을 탐색합니다.

123사오에서 123 이 패턴으로 인식 되었습니다.

123 을 일이삼 으로 교환합니다.


```python
pattern.match("2-2가나다")
```




    <re.Match object; span=(0, 1), match='2'>



이처럼 컴파일한 패턴을 사용할 때에는 re.xxxx 형태가 아닌 사용자가 임의로 지정한 패턴 객체 이름.xxx 형태로 함수들을 사용합니다.

re.purge() -> 패턴으로 저장된 객체들을 지워서 메모리를 확보하는 함수입니다.


```python
re.purge()
pattern.match("2-2가나다")
```




    <re.Match object; span=(0, 1), match='2'>



### 오해하지 맙시다!
re.purge() 를 호출한다고 해서 이미 컴파일된 패턴이 영향을 받지는 않습니다. 같은 계산을 반복하지 않고 저장한 값을 사용하는 하여 성능을 향상시키는 것입니다. 

어떤 수학자가 노트에 계산을 하고 중간 결과들을 적다가 최종적으로 원하는 공식을 찾았다고 합시다. 원하는 공식을 찾았다면, 중간 계산 과정들은 전부 지우고(캐시를 지움) 그 공식만이 남을 겁니다. 그렇다면 노트의 사용량이 줄어들고(메모리) , 나중에 다른 계산을 할때 새로운 중간 결과를 찾을 수 있게 되는 겁니다.!

## escape()
이 함수는 메타 문자를 일반화 하는 함수입니다. 문자열에서 특정 문자를 찾는 정규 표현식을 만들 때, 문자열의 문자들 중 메타 문자로 사용되는 것들을 이스케이프 하여 정확한 일치를 보장합니다.

예를들어서 패턴이 4$라고 해봅시다.


```python
pattern= "4$"
```


```python
escape_pattern =re.escape(pattern)
```


```python
김두한 = "오케이! 땡큐! 오케이 4$!"
```


```python
cmp1= re.compile(pattern)
cmp2=re.compile(escape_pattern)
```


```python
cmp1.sub("사딸라!",김두한)
```




    '오케이! 땡큐! 오케이 4$!'




```python
cmp2.sub("사딸라!",김두한)
```




    '오케이! 땡큐! 오케이 사딸라!!'



매치 객체의 메서드
- 패턴 객체의 메서드를 통해 반환된 매치 객체의 내부 정도에도 접근할 수 있는 메서드 들이 존재합니다.
    - group(): 매치된 문자열 출력
    - start(): 매치 시작지점 인덱스 출력
    - end() : 끝 지점 출력
    -span() : 시작과 끝을 튜플로 출력

### 매치 객체의 그룹화
() 안에 정규 표현식이 들어가면, 그 부분만 그룹화가 이루어집니다. 


```python
p= re.search('(동원)(산업)','동원산업')
grouping=p.groups()
print(grouping)
```

    ('동원', '산업')
    

그룹의 이름 지정: 그룹에 이름을 지정할 때에는, (?P<그룹명> 표현식) 을 씁니다.

## pattern = re.compile(r'(?P\<func>[a-zA-Z_][a-zA-Z0-9_]+)\((?P\<arg>\w+)\)')

이 패턴을 보면, 먼저 첫 번째 그룹은 func 입니다. 첫 글자는 알파벳과_만 가능하고 , 뒷부분에는 알파벳, 숫자 그리고 _ 이 1 이상 올수 있습니다.

두번째 그룹의 그룹 명은 arg 입니다. 두번째 그룹은 영문자+숫자_밑줄입니다.

그룹화를 하는 이유: 매치된 부분을 추출하거나 조작하기 위해 사용됩니다. 그룹 명을 사용해, match.group('그룹명') 식으로 정보에 접근할 수 있습니다.


```python
pattern = re.compile(r'(?P<func>[a-zA-Z_][a-zA-Z0-9_]+)\((?P<arg>\w+)\)')

input_string = 'match(1234)'

match = pattern.match(input_string)

if match: #매치가 성공 한다면, 매치가 존재 한다면
    func_name = match.group('func') #func가 매치된 문자열 반환
    arg = match.group('arg') #arg 가 매치된 문자열 반환
    print(f'Function Name: {func_name}')
    print(f'Argument: {arg}')
else:
    print('No match')

```

    Function Name: match
    Argument: 1234
    

이런 방식으로 각각 어느 부분이 매치가 되었는지 손쉽게 탐색이 가능합니다.

다음의 예제를 들어보겠습니다.


```python
email = " aa           abcde@gmail.com          info"
```

여기서 abcde@gmail.com  부분만 추출하고 싶을때를 고민 해보겠습니다.

이메일의 형식을 생각해 봅시다. 앞에 올수 있는 건, 영어 소문자 그리구 숫자입니다. [a-z][a-z\d]+

중간에 올수 있는 건 @ 그리고 다시 영어 소문자. 그리고 . 그리고 다시 영어 소문자입니다. 

\\@[a-z+]\\.[a-z]+

그러면, \b[a-z][a-z\d]+\@[a-z]+\.[a-z]+\b 가 됩니다. 

앞의 \b 는 단어의 정확한 매칭을 가능하게 해줍니다. \b 를 사용하지 않는다면,
앞뒤에  단어가 있을 경우 그 단어까지 같이 출력될 위험이 있기에 감싸준다고 생각하고 사용합니다.


```python
#정규 표현식을 정의하겠습니다. 
challenge_pattern = re.compile(r'(?P<ID>\b[a-z][a-z\d]+)(?P<domain>\@[a-z]+\.[a-z]+\b)')
```


```python
succes_match=challenge_pattern.search(email)
```


```python
if succes_match:
    User_id = succes_match.group('ID') #스트링 처리!
    User_domain=succes_match.group('domain')
    print(f"유저 아이디:{User_id},도메인 주소:www.{User_domain}")
else:
    print("매칭되는 이메일이 존재하지 않습니다.")
```

    유저 아이디:abcde,도메인 주소:www.@gmail.com
    


```python

```
